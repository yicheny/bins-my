#!/usr/bin/env node

'use strict';

const argv = require('minimist')(process.argv.slice(2));
const colors  = require('colors/safe');
// const path = require('path');
const fs = require('fs')

const sep = '-';
const print = createPrint();

tryExecute(main);

function main(){
    process.title ='file-simple-control'
    if(argv.h || argv.help) printHelpInfo();
    if(argv.v || argv.version) printVersion();
    if(argv.p || argv.prifix) setPrefix();
    if(argv.s || argv.suffix) setSuffix();
}

function createPrint(){
    return {
        info(text){
            console.log(text)
        },
        error(text){
            console.log(colors.red(text))
        }
    }
}

function printHelpInfo(){
    print.info(getHelpInfo());
    process.exit();

    function getHelpInfo(){
        return [
            'usage: dynamic-pack [path] [options]',
            '',
            'options',
            '-h --help          打印这个列表并退出',
            '-v --version       打印当前版本并退出',
            '-p --prefix        设置文件前缀',
            '-s --suffix        批量修改文件后缀，参数base,start,end'
        ].join('\n');
    }
}

function printVersion(){
    print.info('v' + require('../package.json').version);
    process.exit();
}

async function tryExecute(callback){
    try {
        return await callback();
    } catch (err) {
        print.error(err.message)
    }
}

function setPrefix(){
    const newPrefix = argv.p || argv.prefix;
    const rootPath = getRootPath();
    const files = fs.readdirSync(rootPath);
    files.map(filename=>{
        checkSep(filename);
        const [prefix,name] = filename.split(sep);
        if(!prefix) throw new Error("文件名缺少前缀！");
        const newFileName = ''.concat(addZero(newPrefix),'-',name);
        fs.renameSync(filename,newFileName);
    });

    function addZero(n){
        return n<10 ? '0'.concat(n) : n;
    }
}

function setSuffix(){
    const [base,start,end] = getSuffixParams();

    const rootPath = getRootPath();

    //TODO 这里默认文件是按名称进行排序的且文件以数字进行命名，重置顺序让文件从大到小进行覆写以避免其他文件被覆盖，这里使用排序更符合需求，不过js对于这种'01-450.png'的字符串进行sort排序并不能保证按所需排序，想要处理相对麻烦，暂时没有必要，所以使用reverse作为临时方案，不过某些情况下可能出错
    const files = fs.readdirSync(rootPath).reverse();

    const newFileNames = files.map(filename=>{
        checkSep(filename);
        const [prefix,name] = filename.split(sep);
        const [value,suffix] = name.split('.');
        return `${prefix}-${getNewValue(Number(value))}.${suffix}`;
    });
    newFileNames.forEach((x,i)=>{
        // fs.renameSync(files[i],x)
    })

    function getNewValue(v){
        if(v < start || v > end) return v;//注意，比较必须使用数字，如果使用字符串，会有类似 '460' < '50' 这种情况出现
        const newValue = v + base;
        if(newValue <= 0) throw new Error('转换出错：文件主体名必须大于0');
        if(isNaN(newValue)) throw new Error('转换出错：文件主体名必须是数字')
        return addZero(newValue);

        function addZero(n){
            return n<100 ? '0'.concat(n) : n;
        }
    }

    function getSuffixParams(){
        const suffixParamsString = argv.s || argv.suffix;
        if(typeof suffixParamsString !== "string") throw new Error('-s --suffix 参数必须是字符串！');
        const suffixParams = suffixParamsString.split(',');
        if(suffixParams.length < 2) throw new Error('-s --suffix 参数传递不全');
        return suffixParams.map(x=>Number(x));
    }
}

function getRootPath(){
    return getWinPath(process.cwd());
}

function getWinPath(result){
    return result.replace(/\\/g, '/');
}

function checkSep(filename){
    if(!filename.includes(sep)) throw new Error("文件名缺少指定分隔符！");
}
