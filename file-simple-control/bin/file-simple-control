#!/usr/bin/env node

'use strict';

const argv = require('minimist')(process.argv.slice(2));
const colors  = require('colors/safe');
// const path = require('path');
const fs = require('fs')

const utils = createUtils();
const sep = '-';
const print = createPrint();

tryExecute(main);

function main(){
    process.title ='file-simple-control'
    if(argv.h || argv.help) printHelpInfo();
    if(argv.v || argv.version) printVersion();
    if(argv.p || argv.prifix) setPrefix();
    if(argv.s || argv.suffix) setSuffix();
    if(argv.r || argv.reset) resetNames();
}

function createPrint(){
    return {
        info(text){
            console.log(text)
        },
        error(text){
            console.log(colors.red(text))
        }
    }
}

function printHelpInfo(){
    print.info(getHelpInfo());
    process.exit();

    function getHelpInfo(){
        return [
            'usage: dynamic-pack [path] [options]',
            '',
            'options',
            '-h --help          打印这个列表并退出',
            '-v --version       打印当前版本并退出',
            '-p --prefix        设置文件前缀',
            '-s --suffix        批量修改文件后缀，参数base,start,end',
            '-r --reset         批量重置文件名'
        ].join('\n');
    }
}

function printVersion(){
    print.info('v' + require('../package.json').version);
    process.exit();
}

async function tryExecute(callback){
    try {
        return await callback();
    } catch (err) {
        print.error(err.message)
    }
}

function setPrefix(){
    const newPrefix = argv.p || argv.prefix;
    const rootPath = getRootPath();
    const files = fs.readdirSync(rootPath);
    files.forEach(filename=>{
        checkSep(filename);
        const [prefix,name] = filename.split(sep);
        if(!prefix) throw new Error("文件名缺少前缀！");
        const newFileName = ''.concat(addZero(newPrefix),'-',name);
        fs.renameSync(filename,newFileName);
    });

    function addZero(n){
        return n<10 ? '0'.concat(n) : n;
    }
}

function setSuffix(){
    const [base,start,end] = getSuffixParams();

    const files = getRootFiles(Number(base) > 0);
    renameFiles(getNewFileNames(files))
    print.info("批量修改执行完成")

    function getNewFileNames(files){
       return files.map(filename=>{
            return hasSep(filename) ? getNameWithPrefix(filename) : getName(filename)
        });

       function hasSep(filename){
           return filename.includes(sep)
       }

       function getName(name){
           const [value,suffix] = name.split('.');
           return `${getNewValue(value)}.${suffix}`;
       }

       function getNameWithPrefix(filename){
           const [prefix,name] = filename.split(sep);
           return `${prefix}-${getName(name)}`;
       }
    }

    function renameFiles(newFileNames){
        newFileNames.forEach((x,i)=>{
            fs.renameSync(files[i],x)
        })
    }

    function getNewValue(source){
        const v = Number(source);
        if(v < start || v > end) return utils.addZero(v);//注意，比较必须使用数字，如果使用字符串，会有类似 '460' < '50' 这种情况出现
        const newValue = v + base;
        if(newValue <= 0) throw new Error(`转换出错：文件主体名必须大于0，${source}`);
        if(isNaN(newValue)) throw new Error(`转换出错：文件主体名必须是数字，${source}`)
        return utils.addZero(newValue);
    }

    function getSuffixParams(){
        const suffixParamsString = argv.s || argv.suffix;
        if(typeof suffixParamsString !== "string") throw new Error('-s --suffix 参数必须是字符串！');
        const suffixParams = suffixParamsString.split(',');
        if(suffixParams.length < 2) throw new Error('-s --suffix 参数传递不全');
        return suffixParams.map(x=>Number(x));
    }
}

function resetNames() {
    const files = getRootFiles();
    filterIgnore(files).sort(filenameCompare).reverse().forEach((fileName,index,array) => {
        const no = array.length - index;
        fs.renameSync(fileName,`${utils.addZero(no)}.png`);
    })
    print.info("批量重命名执行完成！")

    function filterIgnore(files){
        const IGNORES = ['.zip','.rar','.7z']
        return files.filter(x => !IGNORES.some(i => x.endsWith(i)))
    }

    function filenameCompare(v1,v2){
        const fv1 = getFormatValue(v1);
        const fv2 = getFormatValue(v2);
        if(fv1.sourceNo === fv2.sourceNo) return fv1.appendNo - fv2.appendNo;
        return fv1.sourceNo - fv2.sourceNo;

        function getFormatValue(v){
            const [pureName] = v.split('.')
            const hasAppend = pureName.includes('-')
            if(!hasAppend) return {sourceNo:pureName,hasAppend}
            const [sourceNo,appendNo] = pureName.split('-')
            return {
                hasAppend,
                sourceNo,
                appendNo
            }
        }
    }
}



//公共方法区域
function getRootPath(){
    return getWinPath(process.cwd());
}

function getWinPath(result){
    return result.replace(/\\/g, '/');
}

function getRootFiles(isReverse=true){
    const files = fs.readdirSync(getRootPath());
    //TODO 这里默认文件是按名称进行排序的且文件以数字进行命名，重置顺序让文件从大到小进行覆写以避免其他文件被覆盖，这里使用排序更符合需求，不过js对于这种'01-450.png'的字符串进行sort排序并不能保证按所需排序，想要处理相对麻烦，暂时没有必要，所以使用reverse作为临时方案，不过某些情况下可能出错
    return isReverse ? files.reverse() : files;
}

function checkSep(filename){
    if(!filename.includes(sep)) throw new Error("文件名缺少指定分隔符！");
}

function createUtils(){
    return {
        addZero(n){
            if(n<10) return '00'.concat(n);
            return n<100 ? '0'.concat(n) : n;
        }
    }
}
