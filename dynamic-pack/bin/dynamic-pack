#!/usr/bin/env node

'use strict';

const argv = require('minimist')(process.argv.slice(2));
const colors  = require('colors/safe');
const path = require('path');
const fs = require('fs');
const {exec} = require('child_process');



process.title ='dynamic-pack'

const print = createPrint();

if(argv.h || argv.help) return printHelpInfo();
if(argv.v || argv.version) return printVersion();
if(getConfig()) return setByConfig();
print.error("不是dynamic-pack提供的命令，可以执行dp -h查看当前支持的命令！")


function printHelpInfo(){
    print.info(getHelpInfo());
    process.exit();

    function getHelpInfo(){
        return [
            'usage: dynamic-pack [path] [options]',
            '',
            'options',
            '-h --help              打印这个列表并退出',
            '-v --version           打印当前版本并退出',
            '-c --config            读取配置'
        ].join('\n');
    }
}

function printVersion(){
    print.info('v' + require('../package.json').version);
    process.exit();
}

function getConfig(){
    return argv.c || argv.config
}
async function setByConfig(){
    let originalMainPanel = null;
    const config = require(getAbsoluteFilePath(getConfig()));
    const isRecovery = config.isRecovery;
    const classify = config.classify;
    const classifyConfig = config.classifyConfig[classify];
    const moduleConfig = classifyConfig.moduleConfig;

    dynamic()
    await exeScripts(config.scripts);
    if(isRecovery) recovery();

    function dynamic(){
        setMainPanel();
        print.success('已成功处理MainPanel！');
        replaceModule();
        print.success('已成功调整特殊模块！');

        function setMainPanel(){
            const sourceFile = readFile(getAbsoluteFilePath(classifyConfig.sourceFile));
            if(isRecovery) originalMainPanel = readFile(getAbsoluteFilePath(classifyConfig.targetFile));
            writeTargetPanel(sourceFile);
        }
    }

    async function exeScripts(scripts){
        if(!Array.isArray(scripts)) return null;
        print.primary("\n执行自定义scripts！\n");
        const orderList = scripts.map((s)=>exec_order(s));
        await Promise.all(orderList);
        print.success("自定义scripts执行完毕！\n")
    }

    function recovery(){
        writeTargetPanel(originalMainPanel);
        replaceModule('target','source');
        print.success('已成功还原至初始状态！');
    }

    //公共方法
    function replaceModule(sourceKey='source',targetKey='target'){
        if(!Array.isArray(moduleConfig)) return null;
        moduleConfig.forEach((c)=>{
            const filePath = getAbsoluteFilePath(c.filePath);
            let file = readFile(filePath);
            c.replaceModules.forEach(x=>{
                file = file.replace(x[sourceKey],x[targetKey]);
            });
            fs.writeFileSync(filePath,file)
        })
    }

    function writeTargetPanel(file){
        fs.writeFileSync(getAbsoluteFilePath(classifyConfig.targetFile),file);
    }
}




//基础方法
function readFile(path){
    return fs.readFileSync(path,'utf-8');
}

function getAbsoluteFilePath(filePath){
    const rootPath = getWinPath(process.cwd());
    return getWinPath(path.join(rootPath,filePath));
}

function getWinPath(result){
    return result.replace(/\\/g, '/');
}

function createPrint(){
    return {
        info(text){
            console.log(text)
        },
        primary(coreInfo,...normalInfo){
            console.log(colors.blue(coreInfo),...normalInfo);
        },
        error(coreInfo,...normalInfo){
            console.log(colors.red(coreInfo),...normalInfo)
        },
        success(text){
            console.log(colors.green(text))
        }
    }
}

function exec_order(order, info = '') {
    let i = 1;
    const timeId = setInterval(() => {
        info && console.log(info, i++);
    }, 1000);

    return new Promise((resolve, reject) => {
        exec(order, (err, stdout, stderr) => {
            if (err) return reject(err);
            return resolve(stdout, stderr);
        });
    }).then((stdout, stderr) => {
        print.primary(`${order} stdout：\n`, stdout);
        // console.log('stderr',stderr);
        clearInterval(timeId)
    }).catch(err => {
        print.error(`${order} error：\n`, err);
        clearInterval(timeId)
    });
}
